classdef ClassHistogram < handle
    %written by
    %C.P.Richter
    %Division of Biophysics / Group J.Piehler
    %University of Osnabrueck
    
    properties
        Created
        
        Parent
        FamilyColor
        
        NumSrcData
        SrcData
        
        Data
        NumData
        MinData
        MaxData
        MedianData
        IqrData
        
        KernelWidth
        CDF
        PDF
        X
        
        Alpha = 0.95;
        PosteriorMap
        
        HasUserSelection
        HasPopSelection
        
        objMixModelSettings = ManagerMixedDistSettings.empty;
        
        ExportBin
    end %properties
    properties (Hidden, Transient)
        hFig
        hAx
        hToolbar
        hContextmenu
        hPosteriorCbar
        hPosteriorCbarTitle
        hAlphaSlider
        
        Mode
        hSelectButton
        hSelector
        hAreaPatch
        hSelectionPatch
        BinWidth
        hLimitTxt
        hMinLimitEdit
        hMaxLimitEdit
        
        hSubpopButton
        jSubpopMenu
        
        hFitButton
        
        listenerDestruction
    end %properties
    
    events
        ClosingVisualization
        ObjectDestruction
    end %events
    
    methods
        %constructor
        function this = ClassHistogram(parent,type,objData)
            this.Created = now;
            
            this.Parent = parent;
            this.FamilyColor = this.Parent.FamilyColor;
            
            this.NumSrcData = numel(objData);
            this.SrcData = objData;
            
            this.listenerDestruction = ...
                event.listener(this.Parent,'ObjectDestruction',...
                @(src,evnt)delete_object(this));
            
            %build figure
            this.hFig = figure(...
                'Color',  this.FamilyColor,...
                'Name', 'DISTRIBUTION MANAGER',...
                'NumberTitle', 'off',...
                'MenuBar', 'none',...
                'ToolBar', 'none',...
                'DockControls', 'off',...
                'Units', 'pixels',...
                'Position', set_figure_position(1.7,0.7,'center'),...
                'IntegerHandle','off',...
                'UserData', this,...
                'Visible','on',...
                'Resize','off',...
                'Renderer','opengl',...
                'CloseRequestFcn',@(src,evnt)delete_object(this));
            
            this.hAx(2) = axes(...
                'Parent', this.hFig,...
                'Units', 'normalized',...
                'Position', [0.12 0.18 0.75 0.7],...
                'FontSize',24,...
                'YTick', [0 0.2 0.4 0.6 0.8 1],...
                'XTickLabel','',...
                'TickDir', 'out',...
                'Color',[1 1 1],...
                'LineWidth', 2,...
                'Box','on',...
                'TickLength', [0 0],...
                'NextPlot', 'add');
            this.hAx(1) = ...
                axes(...
                'Parent', this.hFig,...
                'Units', 'normalized',...
                'Position',get(this.hAx(2),'Position'),...
                'FontSize',24,...
                'Color','none',...
                'YAxisLocation','right',...
                'TickDir', 'out',...
                'LineWidth', 2,...
                'Box','on',...
                'TickLength', [0 0],...
                'NextPlot', 'add');
            
            this.hToolbar = uitoolbar(...
                'Parent',this.hFig);
            icon = getappdata(0,'icon');
            uipushtool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Save_Figure'),...
                'ClickedCallback', @(src,evnt)print_figure_to_disk(this.hFig))
            uipushtool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Save_Data'),...
                'ClickedCallback', @(src,evnt)write_variable_to_ascii(this))
            this.hFitButton = ...
                uipushtool(...
                'Parent',this.hToolbar,...
                'Separator','on',...
                'CData', icon.('Fit'));
            this.hSubpopButton = ...
                uitogglesplittool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Set_Subset'),...
                'ClickedCallback', @(src,evnt)select_subpopulation_region(this,src));
            pause(0.05)
            jBin = get(this.hSubpopButton,'JavaContainer');
            pause(0.05)
            this.jSubpopMenu = get(jBin,'MenuComponent');
            %                 set(jOption, 'ActionPerformedCallback', ...
            %                     @(src,evnt)set_traj_subset(this));
            %             <HTML><FONT color="red">User</Font></html>
            this.hSelectButton = ...
                uitoggletool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Selection'),...
                'ClickedCallback', @(src,evnt)select_data_region(this,src));
            uipushtool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Filter_Data'),...
                'ClickedCallback', @(src,evnt)generate_filtered_subset(this))
            uitoggletool(...
                'Parent',this.hToolbar,...
                'Separator','on',...
                'CData', icon.('Zoom'),...
                'Tag','Zoom',...
                'ClickedCallback', @(src,evnt)set_zoom(src,'hFig',this.hFig,'Direction','horizontal'))
            uitoggletool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Pan'),...
                'Tag','Pan',...
                'ClickedCallback', @(src,evnt)set_pan(src,'hFig',this.hFig,'Direction','horizontal'))
            
            uitoggletool(...
                'Parent',this.hToolbar,...
                'CData', icon.('Pencil'),...
                'Tag','PropertyEditor',...
                'ClickedCallback', @(src,evnt)activate_property_editor(this,src))
            
            figPos = get(this.hFig,'Position');
            this.hLimitTxt = ...
            uicontrol(...
                'Style', 'Text',...
                'Units','pixels',...
                'Position', [10 figPos(4)-45 100 40],...
                'FontSize', 20,...
                'String', 'Limits:',...
                'BackgroundColor', this.FamilyColor,...
                'HorizontalAlignment', 'left',...
                'Visible','off');
            
            this.hMinLimitEdit = ...
            uicontrol(...
                'Style', 'edit',...
                'Units','pixels',...
                'Position', [110 figPos(4)-40 150 40],...
                'FontSize', 20,...
                'String', [],...
                'BackgroundColor', [1 1 1],...
                'Visible','off',...
                'Callback', @(src,evnt)set_min_limit(this,src));
            this.hMaxLimitEdit = ...
            uicontrol(...
                'Style', 'edit',...
                'Units','pixels',...
                'Position', [260 figPos(4)-40 150 40],...
                'FontSize', 20,...
                'String', [],...
                'BackgroundColor', [1 1 1],...
                'Visible','off',...
                'Callback', @(src,evnt)set_max_limit(this,src));
            
            this.objMixModelSettings = ManagerMixedDistSettings(this);
            isOK = construct_histogram_specific(this,type);
            if ~isOK
                delete_object(this)
            end %if
        end %fun
        function isOK = construct_histogram_specific(this,type)
            isOK = 1;
            
            switch type
                case 'Pixel Intensity Distribution'
                    xlabel(this.hAx(1), 'Pixel Intensity [photon µm^{-2} ms^{-1}]')
                    
                    header = struct(...
                        'Data', 'Pixel Intensity [photon µm^-2 ms^-1]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Pixel Intensity observed [photon µm^-2 ms^-1]',...
                        'Max_Data','Maximal Pixel Intensity observed [photon µm^-2 ms^-1]',...
                        'Data_Median','Median of observed Pixel Intensity [photon µm^-2 ms^-1]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Pixel Intensity [photon µm^-2 ms^-1]');
                    
                    answer = questdlg(sprintf(...
                        'Carefull! Imagestack Analysis can consume your Memory'), ...
                        'Framerange', 'Actual Frame','Imagestack','Actual Frame');
                    
                    switch answer
                        case 'Actual Frame'
                            for dataIdx = 1:this.NumSrcData
                                this.BinWidth(dataIdx) = this.SrcData(dataIdx).Count2photon/...
                                    (this.SrcData(dataIdx).Px2nm/1000)^2/...
                                    this.SrcData(dataIdx).Frame2msec;
                                this.Data{dataIdx}(:,1) = reshape(crop_image(...
                                    this.SrcData(dataIdx).RawImagedata,...
                                    this.SrcData(dataIdx).FieldOfView(1:4),1),[],1)*this.BinWidth;
                            end %for
                        case 'Imagestack'
                            for dataIdx = 1:this.NumSrcData
                                this.BinWidth(dataIdx) = this.SrcData(dataIdx).Count2photon/...
                                    (this.SrcData(dataIdx).Px2nm/1000)^2/...
                                    this.SrcData(dataIdx).Frame2msec;
                                
                                hProgressbar = ClassProgressbar({'Image Processing...'});
                                
                                %preallocate
                                rawImagedata = zeros(...
                                    this.SrcData(dataIdx).FieldOfView(5)*...
                                    this.SrcData(dataIdx).FieldOfView(6),...
                                    sum(this.SrcData(dataIdx).objImageFile.NumImageFrames));
                                
                                numFranes = sum(this.SrcData(dataIdx).objImageFile.NumImageFrames);
                                for frame = 1:numFranes
                                    isOK = goto_image_frame(this.SrcData(dataIdx).objImageFile,frame);
                                    rawImagedata(:,frame) = reshape(crop_image(read_raw_image(...
                                        this.SrcData(dataIdx).objImageFile),...
                                        this.SrcData(dataIdx).FieldOfView(1:4),1),[],1);
                                    update_progressbar(hProgressbar,{frame/numFranes})
                                end %for
                                close_progressbar(hProgressbar)
                                
                                this.Data{dataIdx} = reshape(rawImagedata,[],1)*this.BinWidth(dataIdx);
                            end %for
                        otherwise
                            isOK = 0;
                            return
                    end %switch
                    this.BinWidth = unique(this.BinWidth);
                    %check if time delays are equal
                    if numel(this.BinWidth) == 1
                        this.Mode = 'discrete';
                        
                        header = catstruct(header, struct(...
                            'Bin_Width', 'Width of Databin',...
                            'Empiric_PMF', 'Estimated Probabilitymass of respective Pixel Intensity (int [s] | pmf(int))',...
                            'Empiric_CMF', 'Estimated Cumulative Probability of respective Pixel Intensity (int [s] | cmf(int))'));
                    else
                        this.Mode = 'continous';
                        
                        header = catstruct(header, struct(...
                            'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                            'Empiric_PDF', 'Estimated Probabilitydensity of respective Pixel Intensity (int [s] | pdf(int))',...
                            'Empiric_CDF', 'Estimated Cumulative Probability of respective Pixel Intensity (int [s] | cdf(int))'));
                    end %if
                    
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Signal Intensity Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Signal Intensity [photon particle^{-1} ms^{-1}]')
                    
                    header = struct(...
                        'Data', 'Signal Intensity [photon particle^-1 ms^-1]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Signal Intensity observed [photon particle^-1 ms^-1]',...
                        'Max_Data','Maximal Signal Intensity observed [photon particle^-1 ms^-1]',...
                        'Data_Median','Median of observed Signal Intensity [photon particle^-1 ms^-1]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Signal Intensity [photon particle^-1 ms^-1]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Signal Intensity (int [photon particle^-1 ms^-1] | pdf(int))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Signal Intensity (int [photon particle^-1 ms^-1] | cdf(int))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = reshape(this.SrcData(dataIdx).Data.Photons,[],1)/this.SrcData(dataIdx).Frame2msec;
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Signal to Noise Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Signal to Noise Ratio [dB]')
                    
                    header = struct(...
                        'Data', 'Signal to Noise Ratio [dB]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Signal to Noise Ratio observed [dB]',...
                        'Max_Data','Maximal Signal to Noise Ratio observed [dB]',...
                        'Data_Median','Median of observed Signal to Noise Ratio [dB]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Signal to Noise Ratio [dB]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Signal to Noise Ratio (snr [dB] | pdf(snr))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Signal to Noise Ratio (snr [dB] | cdf(snr))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = reshape(this.SrcData(dataIdx).Data.SNR,[],1);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Localization Precision Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Localization Precision [nm]')
                    
                    header = struct(...
                        'Data', 'Localization Precision [nm]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Localization Precision observed [nm]',...
                        'Max_Data','Maximal Localization Precision observed [nm]',...
                        'Data_Median','Median of observed Localization Precision [nm]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Localization Precision [nm]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Localization Precision (prec [nm] | pdf(prec))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Localization Precision (prec [nm] | cdf(prec))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = reshape(this.SrcData(dataIdx).Data.Precision,[],1);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Nearest Neighbor Distance Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Nearest Neighbor Distance lg[µm]')
                    
                    header = struct(...
                        'Data', 'Nearest Neighbor Distance lg[µm]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Nearest Neighbor Distance observed lg[µm]',...
                        'Max_Data','Maximal Nearest Neighbor Distance observed lg[µm]',...
                        'Data_Median','Median of observed Nearest Neighbor Distance lg[µm]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Nearest Neighbor Distance lg[µm]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Nearest Neighbor Distance (nn lg[µm] | pdf(nn))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Nearest Neighbor Distance (nn lg[µm] | cdf(nn))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx}(:,1) = log10(reshape(this.SrcData(dataIdx).Data.NN,[],1));
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Signal Size Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Signal Size [nm]')
                    
                    header = struct(...
                        'Data', 'Signal Size [nm]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Signal Size observed [nm]',...
                        'Max_Data','Maximal Signal Size observed [nm]',...
                        'Data_Median','Median of observed Signal Size [nm]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Signal Size [nm]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Signal Size (r [nm] | pdf(r))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Signal Size (r | cdf(r))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx}(:,1) = reshape(this.SrcData(dataIdx).Data.PSFradius*...
                            this.SrcData(dataIdx).Px2nm,[],1);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Localization Density Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Localization Density lg[particle µm^{-2} ms^{-1}]')
                    
                    header = struct(...
                        'Data', 'Localization Density lg[particle µm^-2 ms^-1]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Localization Density observed lg[particle µm^-2 ms^-1]',...
                        'Max_Data','Maximal Localization Density observed lg[particle µm^-2 ms^-1]',...
                        'Data_Median','Median of observed Localization Density lg[particle µm^-2 ms^-1]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Localization Density lg[particle µm^-2 ms^-1]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Localization Density (loc.dens. lg[particle µm^-2 ms^-1] | pdf(loc.dens.))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Localization Density (loc.dens. lg[particle µm^-2 ms^-1] | cdf(loc.dens.))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = log10(this.SrcData(dataIdx).Data.Time/...
                            (bwarea(this.SrcData(dataIdx).DetectionMap)*(this.SrcData(dataIdx).Px2nm/1000)^2)/...
                            this.SrcData(dataIdx).Frame2msec);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Trajectory Lifetime Distribution'
                    xlabel(this.hAx(1), 'Lifetime [s]')
                    
                    header = struct(...
                        'Data', 'Trajectory Lifetime [s]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Trajectory Lifetime observed [s]',...
                        'Max_Data','Maximal Trajectory Lifetime observed [s]',...
                        'Data_Median','Median of observed Trajectory Lifetime [s]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Trajectory Lifetime [s]');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.BinWidth(dataIdx) = this.SrcData(dataIdx).Frame2msec/1000;
                        this.Data{dataIdx} = reshape([this.SrcData(dataIdx).objIndividual(...
                            this.SrcData(dataIdx).ActiveIdx).TotalObsTime],[],1)*this.BinWidth;
                    end %for
                    this.BinWidth = unique(this.BinWidth);
                    %check if time delays are equal
                    if numel(this.BinWidth) == 1
                        this.Mode = 'discrete';
                        
                        header = catstruct(header, struct(...
                            'Bin_Width', 'Width of Databin',...
                            'Empiric_PMF', 'Estimated Probabilitymass of respective Trajectory Lifetime (lifetime [s] | pmf(lifetime))',...
                            'Empiric_CMF', 'Estimated Cumulative Probability of respective Trajectory Lifetime (lifetime [s] | cmf(lifetime))'));
                    else
                        this.Mode = 'continous';
                        
                        header = catstruct(header, struct(...
                            'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                            'Empiric_PDF', 'Estimated Probabilitydensity of respective Trajectory Lifetime (lifetime [s] | pdf(lifetime))',...
                            'Empiric_CDF', 'Estimated Cumulative Probability of respective Trajectory Lifetime (lifetime [s] | cdf(lifetime))'));
                    end %if
                    
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Exp')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Jumpsize Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Jumpsize [nm]')
                    
                    header = struct(...
                        'Data', 'Jumpsize [nm]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Jumpsize observed [nm]',...
                        'Max_Data','Maximal Jumpsize observed [nm]',...
                        'Data_Median','Median of observed Jumpsize [nm]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Jumpsize [nm]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Jumpsize (jumpsize [nm] | pdf(jumpsize))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Jumpsize (jumpsize [nm] | cdf(jumpsize))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = reshape(this.SrcData(dataIdx).Displacement{...
                            this.SrcData(dataIdx).Dt},[],1);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Rayl')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Diffusion Coefficient Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Diffusion Coefficient lg[µm^2 s^{-1}]')
                    
                    header = struct(...
                        'Data', 'Diffusion Coefficient lg[µm^2 s^-1]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Diffusion Coefficient observed lg[µm^2 s^-1]',...
                        'Max_Data','Maximal Diffusion Coefficient observed lg[µm^2 s^-1]',...
                        'Data_Median','Median of observed Diffusion Coefficient lg[µm^2 s^-1]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Diffusion Coefficient lg[µm^2 s^-1]',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Diffusion Coefficient (diff.coeff. lg[µm^2 s^-1] | pdf(diff.coeff.))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Diffusion Coefficient (diff.coeff. lg[µm^2 s^-1] | cdf(diff.coeff.))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = log10(reshape([this.SrcData(dataIdx).objIndividual(...
                            this.SrcData(dataIdx).ActiveIdx).DiffCoeff],[],1));
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Point Score Distribution'
                    this.Mode = 'continous';
                    
                    xlabel(this.hAx(1), 'Point Score')
                    
                    header = struct(...
                        'Data', 'Point Score',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Point Score observed',...
                        'Max_Data','Maximal Point Score observed',...
                        'Data_Median','Median of observed Point Score',...
                        'Data_Interquartil_Range','Interquartil Range of observed Point Score',...
                        'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                        'Empiric_PDF', 'Estimated Probabilitydensity of respective Point Score (score | pdf(score))',...
                        'Empiric_CDF', 'Estimated Cumulative Probability of respective Point Score (score | cdf(score))');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.Data{dataIdx} = reshape(this.SrcData(dataIdx).PntScore,[],1);
                    end %for
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Normal')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
                case 'Cluster Lifetime Distribution'
                    this.Mode = 'discrete';
                    
                    xlabel(this.hAx(1), 'Lifetime [s]')
                    
                    header = struct(...
                        'Data', 'Cluster Lifetime [s]',...
                        'Number_Datapoints', 'Number of Observations',...
                        'Min_Data','Minimal Cluster Lifetime observed [s]',...
                        'Max_Data','Maximal Cluster Lifetime observed [s]',...
                        'Data_Median','Median of observed Cluster Lifetime [s]',...
                        'Data_Interquartil_Range','Interquartil Range of observed Cluster Lifetime [s]');
                    
                    for dataIdx = 1:this.NumSrcData
                        this.BinWidth(dataIdx) = this.SrcData(dataIdx).Frame2msec/1000;
                        this.Data{dataIdx} = reshape(([this.SrcData(dataIdx).objIndividual(...
                            this.SrcData(dataIdx).ActiveIdx).TotalObsTime]),[],1)*this.BinWidth;
                    end %for
                    this.BinWidth = unique(this.BinWidth);
                    %check if time delays are equal
                    if numel(this.BinWidth) == 1
                        this.Mode = 'discrete';
                        
                        header = catstruct(header, struct(...
                            'Bin_Width', 'Width of Databin',...
                            'Empiric_PMF', 'Estimated Probabilitymass of respective Cluster Lifetime (lifetime [s] | pmf(lifetime))',...
                            'Empiric_CMF', 'Estimated Cumulative Probability of respective Cluster Lifetime (lifetime [s] | cmf(lifetime))'));
                    else
                        this.Mode = 'continous';
                        
                        header = catstruct(header, struct(...
                            'Kernel_Width', 'Bandwidth of Kernel Density Estimator',...
                            'Empiric_PDF', 'Estimated Probabilitydensity of respective Cluster Lifetime (lifetime [s] | pdf(lifetime))',...
                            'Empiric_CDF', 'Estimated Cumulative Probability of respective Cluster Lifetime (lifetime [s] | cdf(lifetime))'));
                    end %if
                    
                    %in case of multiple inputs -> pool data
                    data = vertcat(this.Data{:});
                    initialize_model_parameters(this.objMixModelSettings,data,'Exp')
                    
                    set(this.hFitButton,...
                        'ClickedCallback', @(src,evnt)set_parameter(this.objMixModelSettings))
            end %switch
            
            %% calculate density estimate
            if isempty(data)
                %error (# must be > 1)
                waitfor(errordlg('No data found','','modal'))
                isOK = 0;
                return
            end %if
            if numel(unique(data)) == 1
                waitfor(errordlg('Data has zero variance','','modal'))
                isOK = 0;
                return
            end %if
            
            %             generate_colorbar(this)
            
            this.hAx(3) = ...
                axes(...
                'Parent', this.hFig,...
                'Units', 'normalized',...
                'Position',get(this.hAx(1),'Position'),...
                'FontSize',24,...
                'YLim', [0 1],...
                'YTick', [0 0.2 0.4 0.6 0.8 1],...
                'XTickLabel','',...
                'YTickLabel','',...
                'Color','none',...
                'LineWidth', 1,...
                'YGrid','on',...
                'TickLength', [0 0],...
                'NextPlot', 'add');
            
            this.NumData = numel(data);
            this.MinData = nanmin(data);
            this.MaxData = nanmax(data);
            this.MedianData = nanmedian(data);
            this.IqrData = iqr(data);
            
            switch this.Mode
                case 'discrete'
                    ylabel(this.hAx(1),'Probability Mass')
                    ylabel(this.hAx(2),'Cumulative Probability')
                    
                    %recover discrete values
                    minData = round(this.MinData/this.BinWidth);
                    maxData = round(this.MaxData/this.BinWidth);
                    this.X(:,1) = minData*this.BinWidth-this.BinWidth/2:...
                        this.BinWidth:maxData*this.BinWidth+this.BinWidth/2;
                    this.PDF(:,1) = histc(data,this.X(:,1))/this.NumData;
                    this.CDF(:,1) = cumsum(this.PDF(:,1));
                    
                    [xb,yb] = stairs(this.X(:,1),this.PDF(:,1));
                    hArea = area(this.hAx(1), xb, yb, ...
                        'Linewidth', 2,...
                        'EdgeColor', [0.3 0.3 0.3],...
                        'FaceColor', [0.8627 0.8627 0.8627]);
                    
                    [xb,yb] = stairs(this.X(:,1),this.CDF(:,1));
                    line('xdata', xb, ...
                        'ydata', max(0.005,min(0.995,yb)),...
                        'Color',[0 0 0],...
                        'Linestyle', '-',...
                        'Linewidth', 2, ...
                        'Parent', this.hAx(3))
                    
                    set(this.hAx,'XLim', [min(this.X)-this.BinWidth/2 max(this.X)+this.BinWidth/2])
                    
                    %fill ExportBin
                    this.ExportBin = struct(...
                        'Header', header,...
                        'Data', struct(...
                        'Data', data,...
                        'Number_Datapoints', this.NumData,...
                        'Min_Data',this.MinData,...
                        'Max_Data',this.MaxData,...
                        'Data_Median',this.MedianData,...
                        'Data_Interquartil_Range',this.IqrData,...
                        'Bin_Width', this.BinWidth,...
                        'Empiric_PMF', [this.X this.PDF],...
                        'Empiric_CMF', [this.X this.CDF]));
                    
                case 'continous'
                    ylabel(this.hAx(1),'Probability Density')
                    ylabel(this.hAx(2),'Cumulative Probability')
                    
                    nbins = calcnbins(data, 'fd', 2^8, 2^16);
                    [this.KernelWidth,this.PDF(:,1),this.X(:,1),this.CDF(:,1)] =...
                        kde(data,nbins);
                    
                    hArea = area(this.hAx(1), this.X, this.PDF, ...
                        'Linewidth', 2,...
                        'EdgeColor', [0.3 0.3 0.3],...
                        'FaceColor', [0.8627 0.8627 0.8627]);
                    
                    line('xdata', reshape([data data...
                        nan(this.NumData,1)].',3*this.NumData,1), ...
                        'ydata', reshape([zeros(this.NumData,1)...
                        ones(this.NumData,1)*0.05...
                        zeros(this.NumData,1)].',3*this.NumData,1),...
                        'Color','k',...
                        'Linestyle', '-',...
                        'LineWidth',0.5,...
                        'Parent', this.hAx(2))
                    
                    line('xdata', this.X, ...
                        'ydata', max(0.005,min(0.995,this.CDF)),...
                        'Color','k',...
                        'Linestyle', '-',...
                        'Linewidth', 2, ...
                        'Parent', this.hAx(3))
                    
                    set(this.hAx,'XLim', [min(this.X) max(this.X)])
                    
                    
                    %fill ExportBin
                    this.ExportBin = struct(...
                        'Header', catstruct(header,struct(...
                        'Fitted_PDF', 'Fitted Probabilitydensity (x | pdf(x|subset) | pdf(x|sum))',...
                        'Subset_Probability', 'Estimated Subset Probability (p(x element of subset | pdf(x|subset)))',...
                        'Fit_Parameter', 'Fit Settings and Estimated Parameter (Lower | Init.Value | Upper | Est.Value | 95% CI)')),...
                        'Data', catstruct(struct(...
                        'Data', data,...
                        'Number_Datapoints', this.NumData,...
                        'Min_Data',this.MinData,...
                        'Max_Data',this.MaxData,...
                        'Data_Median',this.MedianData,...
                        'Data_Interquartil_Range',this.IqrData,...
                        'Kernel_Width', this.KernelWidth,...
                        'Empiric_PDF', [this.X this.PDF],...
                        'Empiric_CDF', [this.X this.CDF]),...
                        struct('Fitted_PDF',[],...
                        'Subset_Probability',[],...
                        'Fit_Parameter', [])));
                    
            end %switch
            this.hAreaPatch = get(hArea,'children');
            set(this.hAreaPatch,'FaceAlpha',0.5)
            
            set(this.hAx(1), 'YLim', [0 max(this.PDF)])
            set(this.hAx(2), 'YLim', [0 max(this.CDF)])
            linkaxes(this.hAx,'x')
            
            legend(this.hAx(3),{sprintf(...
                '\t # = %.0f\n min = %.3e\n max = %.3e\n median = %.3e\n iqr = %.3e',...
                this.NumData, this.MinData,this.MaxData,this.MedianData,this.IqrData)},...
                'Color',[1 1 1],...
                'EdgeColor',[0 0 0],...
                'FontSize', 12,...
                'LineWidth', 2,...
                'Box', 'on')
            
            %generate selection bars
            this.hSelector = imrect(this.hAx(3), ...
                [min(this.X) 0 range(this.X) max(this.CDF)]);
            fcn = makeConstrainToRectFcn('imrect',...
                [min(this.X) max(this.X)],[0 max(this.CDF)]);
            setPositionConstraintFcn(this.hSelector,fcn);
            hList = get(this.hSelector,'Children');
            set(hList([1 2 3 5 6 7]),...
                'Marker','none',...
                'LineStyle','none',...
                'ButtonDownFcn',[])
            set(hList([4 8]),...
                'MarkerSize',15,...
                'MarkerFaceColor', [1 0 0],...
                'MarkerEdgeColor', [1 0 0])
            set(hList([9 11]),...
                'LineStyle','none',...
                'ButtonDownFcn',[])
            set(hList([10 12]),...
                'LineWidth',3,...
                'LineStyle','-','Color',[1 0 0])
            set(hList([14 15]),...
                'LineStyle','none')
            set(hList(13),...
                'UIContextMenu',[])
            addNewPositionCallback(...
                this.hSelector,@this.update_selection);
            set(this.hSelector,...
                'Visible','off',...
                'Hittest','off')
            
            set(this.hFig,'Visible','on')
        end %fun
                
        %% manual data selection
        function select_data_region(this,src)
            switch get(src,'State')
                case 'on'
                    if strcmp(get(this.hSubpopButton,'State'),'on')
                        set(this.hSubpopButton,'State','off')
                        select_subpopulation_region(this,this.hSubpopButton)
                    end %if
                    
                    this.HasUserSelection = 1;
                    set(this.hSelector,...
                        'Visible','on',...
                        'Hittest','on')
                    
                    xLimits = getPosition(this.hSelector);
                    
                    switch this.Mode
                        case 'discrete'
                            xdata = get(this.hAreaPatch,'XData');
                            ydata = get(this.hAreaPatch,'YData');
                            good = xdata >= xLimits(1) & ...
                                xdata <= xLimits(1)+xLimits(3);
                            this.hSelectionPatch =  patch(...
                                [xLimits(1); xdata(good); ...
                                xLimits(1)+xLimits(3)],....
                                [0; ydata(good); 0],...
                                [0 1 0],...
                                'EdgeColor','none',...
                                'FaceAlpha', 0.7,...
                                'Parent', this.hAx(1));
                        case 'continous'
                            good = this.X >= xLimits(1) & ...
                                this.X <= xLimits(1)+xLimits(3);
                            this.hSelectionPatch =  patch(...
                                [xLimits(1); this.X(good); ...
                                xLimits(1)+xLimits(3)],....
                                [0; this.PDF(good); 0],...
                                [0 1 0],...
                                'EdgeColor','none',...
                                'FaceAlpha', 0.7,...
                                'Parent', this.hAx(1));
                    end %switch
                    
                    set([this.hLimitTxt,this.hMinLimitEdit,this.hMaxLimitEdit],...
                        'Visible','on',...
                        'Hittest','on')
                    set(this.hMinLimitEdit,...
                        'String',xLimits(1))
                    set(this.hMaxLimitEdit,...
                        'String',xLimits(1)+xLimits(3))
                    
                case 'off'
                    this.HasUserSelection = 0;
                    set(this.hSelector,...
                        'Visible','off',...
                        'Hittest','off')    
                    set([this.hLimitTxt,this.hMinLimitEdit,this.hMaxLimitEdit],...
                        'Visible','off',...
                        'Hittest','off')
                                        
                    delete(this.hSelectionPatch)
            end %switch
        end %fun
        function update_selection(this,position)
            switch this.Mode
                case 'discrete'
                    xdata = get(this.hAreaPatch,'XData');
                    ydata = get(this.hAreaPatch,'YData');
                    good = xdata >= position(1) & ...
                        xdata <= position(1)+position(3);
                    set(this.hSelectionPatch,...
                        'XData', xdata(good),...
                        'YData', ydata(good))
                case 'continous'
                    good = this.X >= position(1) & ...
                        this.X <= position(1)+position(3);
                    set(this.hSelectionPatch,...
                        'XData', [position(1); this.X(good); position(1)+position(3)],...
                        'YData', [0; this.PDF(good); 0])
            end %switch
            
            set(this.hMinLimitEdit,'String',position(1))
            set(this.hMaxLimitEdit,'String',position(1)+position(3))
        end %fun
        
        function set_min_limit(this,src)
            xLimits = getPosition(this.hSelector); %position of selection patch
            
            value = str2double(get(src,'String'));
            value = min(str2double(get(this.hMaxLimitEdit,'String')),max(min(this.X),value));
            
            xLimits(3) = xLimits(3) + (xLimits(1) - value);
            xLimits(1) = value;
            update_selection(this,xLimits)
            
            setPosition(this.hSelector,xLimits)                 
        end %fun
        function set_max_limit(this,src)
            xLimits = getPosition(this.hSelector); %position of selection patch
            
            value = str2double(get(src,'String'));
            value = max(str2double(get(this.hMinLimitEdit,'String')),min(max(this.X),value));
            
            xLimits(3) = xLimits(3) + (value - (xLimits(1) + xLimits(3)));
            update_selection(this,xLimits)
                        
            setPosition(this.hSelector,xLimits)
        end %fun
        
        %% subpopulation based data selection
        function select_subpopulation_region(this,src)
            if isempty(this.objMixModelSettings.SelectedPop)
                set(src,'State','off')
            else
                switch get(src,'State')
                    case 'on'
                        this.HasPopSelection = 1;
                        
                        %make sure user and population selection stay exclusive
                        if strcmp(get(this.hSelectButton,'State'),'on')
                            set(this.hSelectButton,'State','off')
                            select_data_region(this,this.hSelectButton)
                        end %if
                        
                        generate_colorbar(this)
                        
                        select_subpopulation(this.objMixModelSettings,...
                            this.objMixModelSettings.SelectedPop)
                    case 'off'
                        this.HasPopSelection = 0;
                        
                        delete(this.objMixModelSettings.hPosteriorPatch)
                        delete(this.hPosteriorCbar)
                        delete(this.hAlphaSlider)
                        this.objMixModelSettings.hPosteriorPatch = [];
                        
                        linkprop(this.hAx([2 1 3]),'Position');
                end %switch
            end %if
        end %fun
        function generate_colorbar(this)
            this.PosteriorMap = hot(1000);
            trusted = ceil(this.Alpha*1000);
            this.PosteriorMap = [hot(trusted);...
                repmat([0 1 0],1000-trusted+1,1)];
%             this.PosteriorMap(trusted:end,:) = ...
%                 repmat([0 1 0],1000-trusted+1,1);
            colormap(this.hAx(2),this.PosteriorMap)
            
            this.hPosteriorCbar = colorbar('peer', this.hAx(2), 'location','northoutside');
            this.hPosteriorCbarTitle = xlabel(this.hPosteriorCbar, ...
                sprintf('Subset Probability (Alpha = %.3f)',this.Alpha));
            
            linkprop(this.hAx([2 1 3]),'Position');
            set(this.hPosteriorCbar, 'XTickLabel', ...
                get(this.hPosteriorCbar,'XTick')/1000)
            drawnow expose
            
            this.hAlphaSlider = ...
                uicontrol(...
                'Parent', this.hFig,...
                'Style', 'slider',...
                'Units', 'normalized',...
                'Position', get(this.hPosteriorCbar,'Position')-[0.018 -0.014 -0.035 0.03],...
                'Min', 0,...
                'Max', 1,...
                'Value', this.Alpha,....
                'SliderStep', [0.001 0.01]);
            addlistener(this.hAlphaSlider, 'ContinuousValueChange',...
                @(src,evnt)update_posterior_map(this,src));
        end %fun
        function update_posterior_map(this,src)
            this.Alpha = get(src,'Value');
            trusted = ceil(this.Alpha*1000);
            this.PosteriorMap = [hot(trusted);...
                repmat([0 1 0],1000-trusted+1,1)];
            colormap(this.hAx(2),this.PosteriorMap)
            
            set(this.hPosteriorCbarTitle,...
                'String',...
                sprintf('Subset Probability (Alpha = %.3f)',this.Alpha))
        end %fun

        function generate_filtered_subset(this)
            if this.HasUserSelection
                xLimits = getPosition(this.hSelector);
                good = cellfun(@(x) x >= xLimits(1) &...
                    x <= xLimits(1)+xLimits(3),this.Data,'Un',0);
            elseif this.HasPopSelection
                tolLim = 1E-6;
                
                dataMin = min(vertcat(this.Data{:}));
                dataMax = max(vertcat(this.Data{:}));
                
                %start with full data width
                x = linspace(dataMin,dataMax,1000);
                dx = range(x)/1000;
                posterior = this.objMixModelSettings.Posterior(...
                    :,this.objMixModelSettings.SelectedPop);
                
                %greedy solution
                good = (posterior >= log(this.Alpha));
                if ~any(good) %(=no point exceeds confidence treshold)
                    
                    %                     sampling = 1000;
                    %                     while ~any(good)
                    %                         sampling = sampling*10;
                    x = linspace(dataMin,dataMax,1E5);
                    dx = range(x)/1E5;
                    [~, posterior] = evaluate_model_mixture(...
                        this.objMixModelSettings.Candidate,x);
                    good = (posterior(:,this.objMixModelSettings.SelectedPop) >= ...
                        log(this.Alpha));
                    if ~any(good)
                        waitfor(errordlg('No Point meets probability criteria',''))
                        return
                    end %if
                    %                         if dx <= tolLim %(=actual resolution below tolerance)
                    %                             answer = questdlg(sprintf(...
                    %                                 'No Point meets probability criteria within %.0E Resolution',tolLim*10),...
                    %                                 sprintf('Increase Resolution to %.0E',tolLim*10),'Abort','Abort');
                    %                             switch answer
                    %                                 case sprintf('Increase Resolution to %.0E',tolLim*10)
                    %                                     tolLim = tolLim*10;
                    %                                 case 'Abort'
                    %                                     return
                    %                             end %switch
                    %                         end %if
                    %                     end %while
                end %if
                
                if sum(good) == 1 %(=one point contains both limits)
                    lim0 = x(good);
                    
                    %expand around single point
                    while sum(good) == 1 %(= break when two seperated limits are found)
                        x = linspace(lim0-dx/2,lim0+dx/2,1000);
                        dx = dx/1000;
                        [~, posterior] = evaluate_model_mixture(...
                            this.objMixModelSettings.Candidate,x);
                        good = (posterior(:,this.objMixModelSettings.SelectedPop) >= ...
                            log(this.Alpha));
                        if dx <= tolLim %(=actual resolution below tolerance)
                            answer = questdlg(sprintf(...
                                'No seperated Limits found within %.0E Resolution',tolLim*10),...
                                sprintf('Increase Resolution to %.0E',tolLim*10),'Abort','Abort');
                            switch answer
                                case sprintf('Increase Resolution to %.0E',tolLim*10)
                                    tolLim = tolLim*10;
                                case 'Abort'
                                    return
                            end %switch
                        end %if
                    end %while
                end %if
                dx0 = dx;
                
                %find exact solution
                limMin = x(find(good,1,'first'));
                limMax = x(find(good,1,'last'));
                
                %expand around lower limit
                while dx > tolLim %(= break when resolution exceeds tolerance)
                    x = linspace(limMin-dx,limMin+dx,1000);
                    dx = 2*dx/1000;
                    [~, posterior] = evaluate_model_mixture(...
                        this.objMixModelSettings.Candidate,x);
                    good = (posterior(:,this.objMixModelSettings.SelectedPop) >= ...
                        log(this.Alpha));
                    limMin = x(find(good,1,'first'));
                    if limMin <= dataMin
                        answer = questdlg('Lower Confidence Limit exceeds min. Data Value','',...
                            'Set Lower Confidence Limit to min. Data Value', 'Abort','Abort');
                        switch answer
                            case 'Set Lower Confidence Limit to min. Data Value'
                                limMin = dataMin;
                                break
                            case 'Abort'
                                return
                        end %switch
                    end %if
                end %while
                
                dx = dx0;
                %expand around upper limit
                while dx > tolLim %(= break when resolution exceeds tolerance)
                    x = linspace(limMax-dx,limMax+dx,1000);
                    dx = 2*dx/1000;
                    [~, posterior] = evaluate_model_mixture(...
                        this.objMixModelSettings.Candidate,x);
                    good = (posterior(:,this.objMixModelSettings.SelectedPop) >= ...
                        log(this.Alpha));
                    limMax = x(find(good,1,'first'));
                    if limMax >= dataMax
                        answer = questdlg('Upper Confidence Limit exceeds max. Data Value','',...
                            'Set Upper Confidence Limit to max. Data Value', 'Abort','Abort');
                        switch answer
                            case 'Set Upper Confidence Limit to max. Data Value'
                                limMax = dataMax;
                                break
                            case 'Abort'
                                return
                        end %switch
                    end %if
                end %while
                
                %apply limits to data
                good = cellfun(@(x) x >= limMin &...
                    x <= limMax,this.Data,'Un',0);
            end
            
            for dataIdx = 1:this.NumSrcData
                if exist('good','var')
                    if sum(good{dataIdx}) > 0
                        if any(strcmp(class(this.SrcData),{'ClassTrajectory','ClassCluster'}))                              
                                good_ = false(this.SrcData(dataIdx).NumIndividual,1);
                                good_(this.SrcData(dataIdx).ActiveIdx) = good{dataIdx};
                                good{dataIdx} = good_;
                        end %if
                        generate_new_data_set(this.SrcData(dataIdx),good{dataIdx})
                    else
                        waitfor(errordlg('No data within selected limits','','modal'))
                    end %if
                else
                    waitfor(errordlg('No data selected','','modal'))
                end %if
            end %for            
        end %fun
        
        %%
        function activate_property_editor(this,src)
            switch get(src,'State')
                case 'on'
                    propertyeditor('on')
                case 'off'
                    propertyeditor('off')
                    set(this.hFig,'WindowStyle','Normal',...
                        'Selected','off','DockControls','off')
                    set(findall(this.hFig),'Selected','off')
            end %switch
        end %fun
        
        %%
        function close_object(this)
            notify(this,'ClosingVisualization')
        end %fun
        function delete_object(this)
            notify(this,'ObjectDestruction')
            
            if ishandle(this.hFig)
                delete(this.hFig)
            end %if
            
            delete(this)
        end %fun
    end %methods
end %classdef